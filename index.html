<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Шахматы 10x8 с Змеёй</title>
<style>
  :root{--cell-size:80px}
  body{font-family: Arial, Helvetica, sans-serif; display:flex; gap:16px; padding:16px; background:#f0f0f0}
  /* слева пойманные белые, центр - доска, справа пойманные чёрные */
  .cap-col{width:140px; display:flex; flex-direction:column; gap:10px; align-items:center}
  .cap-title{font-weight:700; margin-bottom:6px}
  .cap-box{width:120px; min-height:80px; background:#fff; padding:6px; border-radius:6px; box-shadow:inset 0 0 0 1px rgba(0,0,0,0.06); display:flex; flex-wrap:wrap; gap:4px; justify-content:flex-start}
  .cap-box img{width:40px; height:40px; user-select:none; pointer-events:none}
  .game-wrap{display:flex; align-items:flex-start; gap:16px}
  .board{
  width:calc(var(--cell-size)*10);
  height:calc(var(--cell-size)*8);
  display:grid;
  grid-template-columns:repeat(10,var(--cell-size));
  grid-template-rows:repeat(8,var(--cell-size));
  box-shadow:0 8px 20px rgba(0,0,0,.15);
  border:5px solid #000;   /* <<< ДОБАВЛЕНО */
  position:relative;}
  .cell{width:var(--cell-size); height:var(--cell-size); position:relative; overflow:hidden}
  .cell .bg{position:absolute; inset:0; background-size:cover; background-position:center}
  .overlay{position:absolute; inset:0; cursor:pointer}
  .piece{width:64px; height:64px; position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); pointer-events:none; user-select:none}
  .highlight-selected{background:rgba(128,0,0,0.45);}
  .highlight-move{background:rgba(0,128,0,0.35);}
  /* небольшие адаптивные стили */
  @media (max-width:960px){ body{flex-direction:column; align-items:center} .cap-col{flex-direction:row; gap:8px} .cap-box{width:100%; justify-content:center} }
</style>
</head>
<body>
  <div class="cap-col" id="cap-white-col">
    <div class="cap-box" id="cap-white-pieces" style="margin-top:6px"></div>
	<div class="cap-box" id="cap-white-pawns"></div>
  </div>

  <div class="game-wrap">
    <div id="board" class="board" aria-label="Шахматная доска"></div>
  </div>

  <div class="cap-col" id="cap-black-col">
        
    <div class="cap-box" id="cap-black-pieces" style="margin-top:6px"></div>
	<div class="cap-box" id="cap-black-pawns"></div>
  </div>

<script>
// --- Конфигурация ---
const COLS = 10, ROWS = 8;
const IMG_PATH = 'img/';
const cellImgs = { white: 'wcell.jpg', black: 'bcell.jpg' };
const pieceImgs = {
  b: {rook:'brook.png', knight:'bknight.png', bishop:'bbishop.png', queen:'bqueen.png', king:'bking.png', pawn:'bpawn.png', snake:'bsnake.png'},
  w: {rook:'wrook.png', knight:'wknight.png', bishop:'wbishop.png', queen:'wqueen.png', king:'wking.png', pawn:'wpawn.png', snake:'wsnake.png'}
};
// порядок на стартовой линии
const backRank = ['rook','knight','bishop','snake','queen','king','snake','bishop','knight','rook'];

// --- состояние игры ---
let board = [];
let turn = 'w'; // кто ходит
let selected = null; // {x,y}
let capWhitePawns = [], capWhitePieces = [], capBlackPawns = [], capBlackPieces = [];

// DOM
const boardEl = document.getElementById('board');
const cwp = document.getElementById('cap-white-pawns'), cwp2 = document.getElementById('cap-white-pieces');
const cbp = document.getElementById('cap-black-pawns'), cbp2 = document.getElementById('cap-black-pieces');

// --- помощь ---
function inside(x,y){ return x>=0 && x<COLS && y>=0 && y<ROWS; }
function isAlly(piece,color){ return piece && piece.color===color; }

// --- установка начальной позиции ---
function setup(){
  board = Array.from({length:ROWS}, ()=>Array(COLS).fill(null));
  for(let x=0;x<COLS;x++){
    board[0][x] = {type: backRank[x], color:'b', moved:false};
    board[1][x] = {type: 'pawn', color:'b', moved:false};
    board[6][x] = {type: 'pawn', color:'w', moved:false};
    board[7][x] = {type: backRank[x], color:'w', moved:false};
  }
  capWhitePawns = []; capWhitePieces = []; capBlackPawns = []; capBlackPieces = [];
  turn = 'w';
}

// --- отрисовка доски ---
function render(){
  boardEl.innerHTML = '';
  for(let y=0;y<ROWS;y++){
    for(let x=0;x<COLS;x++){
      const cell = document.createElement('div'); cell.className='cell';
      cell.dataset.x = x; cell.dataset.y = y;
      const isWhite = ((x+y)%2===0);
      const bg = document.createElement('div'); bg.className='bg';
      bg.style.backgroundImage = `url(${IMG_PATH}${isWhite?cellImgs.white:cellImgs.black})`;
      cell.appendChild(bg);
      const overlay = document.createElement('div'); overlay.className='overlay';
      overlay.addEventListener('click', ()=>onCellClick(x,y));
      cell.appendChild(overlay);
      const p = board[y][x];
      if(p){
        const img = document.createElement('img'); img.className='piece';
        img.src = IMG_PATH + pieceImgs[p.color][p.type];
        img.draggable = false;
        cell.appendChild(img);
      }
      boardEl.appendChild(cell);
    }
  }
  refreshHighlights();
  updateCapturedDisplay();
}

// --- подсветки / выделение ---
function refreshHighlights(){
  document.querySelectorAll('.overlay').forEach(o=>{ o.classList.remove('highlight-selected','highlight-move'); });
  if(!selected) return;
  const sel = document.querySelector(`.cell[data-x='${selected.x}'][data-y='${selected.y}'] .overlay`);
  if(sel) sel.classList.add('highlight-selected');
  const movesList = generateMoves(selected.x, selected.y);
  movesList.forEach(m=>{
    const el = document.querySelector(`.cell[data-x='${m.x}'][data-y='${m.y}'] .overlay`);
    if(el) el.classList.add('highlight-move');
  });
}

// --- клики по клетке ---
function onCellClick(x,y){
  const p = board[y][x];
  if(selected){
    const mv = generateMoves(selected.x, selected.y);
    const ok = mv.find(m=>m.x===x && m.y===y);
    if(ok){
      makeMove(selected.x, selected.y, x, y);
      selected = null; render(); return;
    }
  }
  if(p && p.color===turn){ selected = {x,y}; render(); }
  else { selected = null; render(); }
}

// --- выполнение хода (и захват) ---
function makeMove(sx,sy,tx,ty){
  const piece = board[sy][sx]; if(!piece) return;
  const target = board[ty][tx];
  if(target){
    if(target.color==='w'){
      if(target.type==='pawn') capWhitePawns.push(target); else capWhitePieces.push(target);
    } else {
      if(target.type==='pawn') capBlackPawns.push(target); else capBlackPieces.push(target);
    }
  }
  board[ty][tx] = {...piece, moved:true};
  board[sy][sx] = null;

  // пешка - превращение
  if(board[ty][tx].type==='pawn'){
    if((board[ty][tx].color==='w' && ty===0) || (board[ty][tx].color==='b' && ty===ROWS-1)){
      const choice = prompt('Преобразование пешки в: (rook,knight,bishop,queen,snake)', 'queen');
      const allowed = ['rook','knight','bishop','queen','snake'];
      board[ty][tx].type = allowed.includes(choice)?choice:'queen';
    }
  }
  // переключение хода
  turn = (turn==='w')? 'b' : 'w';
  updateCapturedDisplay();
}

// --- отображение пойманных ---
function updateCapturedDisplay(){
  cwp.innerHTML=''; cwp2.innerHTML=''; cbp.innerHTML=''; cbp2.innerHTML='';
  function addTo(parent, arr){ arr.forEach(p=>{ const img = document.createElement('img'); img.src = IMG_PATH + pieceImgs[p.color][p.type]; parent.appendChild(img); }); }
  addTo(cwp, capWhitePawns); addTo(cwp2, capWhitePieces);
  addTo(cbp, capBlackPawns); addTo(cbp2, capBlackPieces);
}

// --- генерация ходов по типу фигуры ---
function generateMoves(x,y){
  const p = board[y][x]; if(!p) return [];
  const type = p.type, color = p.color;
  if(type==='king') return genKing(x,y,color);
  if(type==='queen') return genQueen(x,y,color);
  if(type==='rook') return genRook(x,y,color);
  if(type==='bishop') return genBishop(x,y,color);
  if(type==='knight') return genKnight(x,y,color);
  if(type==='pawn') return genPawn(x,y,color);
  if(type==='snake') return genSnake(x,y,color);
  return [];
}

// --- вспомогательная для лучевых фигур ---
function rayMoves(x,y,dirs,color){
  const res = [];
  for(const d of dirs){
    let nx = x + d[0], ny = y + d[1];
    while(inside(nx,ny)){
      const t = board[ny][nx];
      if(!t){ res.push({x:nx,y:ny}); }
      else { if(t.color!==color) res.push({x:nx,y:ny}); break; }
      nx += d[0]; ny += d[1];
    }
  }
  return res;
}

// король
function genKing(x,y,color){
  const del = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
  const res = [];
  for(const d of del){
    const nx = x+d[0], ny = y+d[1];
    if(!inside(nx,ny)) continue;
    const t = board[ny][nx];
    if(!isAlly(t,color)) res.push({x:nx,y:ny});
  }
  return res;
}

// ферзь
function genQueen(x,y,color){
  return rayMoves(x,y,[[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]], color);
}

// ладья
function genRook(x,y,color){
  return rayMoves(x,y,[[1,0],[-1,0],[0,1],[0,-1]], color);
}

// слон
function genBishop(x,y,color){
  return rayMoves(x,y,[[1,1],[1,-1],[-1,1],[-1,-1]], color);
}

// конь
function genKnight(x,y,color){
  const del = [[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]];
  const res = [];
  for(const d of del){
    const nx = x+d[0], ny = y+d[1];
    if(!inside(nx,ny)) continue;
    const t = board[ny][nx];
    if(!isAlly(t,color)) res.push({x:nx,y:ny});
  }
  return res;
}

// пешка
function genPawn(x,y,color){
  const dir = (color==='w') ? -1 : 1; // белые идут вверх (уменьшение y)
  const res = [];
  const fy = y + dir;
  // один шаг
  if(inside(x,fy) && !board[fy][x]) res.push({x:x,y:fy});
  // два шага с начальной позиции
  const startRow = (color==='w')?6:1;
  const fy2 = y + 2*dir;
  if(y===startRow && inside(x,fy2) && !board[fy][x] && !board[fy2][x]) res.push({x:x,y:fy2});
  // взятия по диагонали
  for(const dx of [-1,1]){
    const nx = x + dx, ny = y + dir;
    if(inside(nx,ny) && board[ny][nx] && board[ny][nx].color!==color) res.push({x:nx,y:ny});
  }
  return res;
}

// --- ЗМЕЯ (вариант C) ---

function genSnake(x, y, color){
  // диагональные векторы
  const diag = {
    NE: [1, -1],
    NW: [-1, -1],
    SE: [1, 1],
    SW: [-1, 1]
  };

  // перечисляем ровно те 8 шаблонов, которые ты дал (каждый — массив из двух направлений, чередуем)
  const patterns = [
    ['NW','NE'], ['NE','NW'],
    ['NE','SE'], ['SE','NE'],
    ['SE','SW'], ['SW','SE'],
    ['SW','NW'], ['NW','SW']
  ];

  const res = [];

  // Выполняем симуляцию для каждого шаблона
  for(const pat of patterns){
    let cx = x, cy = y;
    for(let step = 1; step <= 4; step++){
      const dirName = pat[(step-1) % 2];          // чередуем первые/вторые направления
      const d = diag[dirName];
      cx += d[0]; cy += d[1];

      // стоп — вышли за доску
      if(!inside(cx, cy)) break;

      const t = board[cy][cx];
      // стоп — своя фигура блокирует
      if(t && t.color === color) break;

      // допустимый ход (включая взятие)
      res.push({x: cx, y: cy});

      // если взяли вражескую фигуру — остановиться дальше по этому паттерну
      if(t && t.color !== color) break;
    }
  }

  // убрать дубликаты (разные шаблоны могут дать одни и те же клетки)
  const seen = {};
  return res.filter(m => {
    const k = m.x + ',' + m.y;
    if(seen[k]) return false;
    seen[k] = true;
    return true;
  });
}



// --- инициализация ---
setup();
render();

</script>
</body>
</html>
